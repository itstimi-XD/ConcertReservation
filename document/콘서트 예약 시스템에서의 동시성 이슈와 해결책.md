# **콘서트 예약 시스템에서의 동시성 이슈와 해결책**

## **1. 서론**

### 1.1 과제 목적

-  레디스를 적용하는 단계로 넘어가기 이전, 가능한 최대한 데이터베이스의 락과 트랜잭션을 이용하여 동시성 문제를 해결하는 방법을 깊이 있게 연구해보려 합니다.
- 동시성 이슈 파악, 동시성 제어 방식 도입, 장단점 파악 및 비교를 진행하려합니다.
- 
### 1.2 테스트 도구 소개

- **k6**는 Web Application, API, Microservices 등의 성능을 테스트하기 위한 오픈소스 도구입니다.
- 스크립트를 작성하여 테스트를 수행하고, 결과를 분석할 수 있습니다.
- 

## **2. 동시성 이슈 분석**

### 2.1 시나리오 설명

-  상황 1 : 두 명 이상의 사용자가 동시에 같은 좌석을 선택하고 예약 버튼을 누르는 경우. ->  **좌석 중복 예약 문제**
-  상황 2 : 한 명의 사용자가 동시에 본인의 계정으로 탭 3개를 띄워놓는다던지 하는 방식으로 포인트 사용을 시도하는 경우. ->  **포인트 중복 사용 문제**

### 2.2 문제의 영향

- **데이터 무결성 위반**: 동시성 이슈로 인해 좌석이 초과 예약되거나 포인트 잔액이 음수가 되는 등 데이터의 일관성이 깨질 수 있습니다.
- **고객 신뢰 하락**: 사용자들은 시스템에 대한 신뢰를 잃을 수 있으며, 이는 서비스의 평판에 부정적인 영향을 미칩니다.
- **시스템 안정성 저하**: 동시성 문제가 해결되지 않으면 시스템 오류와 비정상 동작이 발생하여 전체적인 안정성이 떨어집니다.


## **3. 동시성 제어 방식 소개**

### 3.1 데이터베이스 락과 트랜잭션

동시성 문제를 해결하기 위해 이번 주차에는 데이터베이스에서 제공하는 락과 트랜잭션을 활용합니다.

#### 3.1.1 락의 종류

- **행 락(Row Lock)**: 특정 행(row)에 대해 락을 걸어 다른 트랜잭션이 해당 행을 수정하지 못하게 합니다.
- **테이블 락(Table Lock)**: 테이블 전체에 락을 걸어 다른 트랜잭션이 테이블에 접근하지 못하게 합니다.

#### 3.1.2 트랜잭션 원리

- **ACID 특성**:
    - **원자성(Atomicity)**: 트랜잭션 내의 모든 작업이 모두 수행되거나 모두 수행되지 않아야 합니다.
    - **일관성(Consistency)**: 트랜잭션이 완료되면 데이터베이스는 일관성 있는 상태를 유지해야 합니다.
    - **격리성(Isolation)**: 동시에 실행되는 트랜잭션들은 서로 간섭하지 않아야 합니다.
    - **지속성(Durability)**: 트랜잭션이 커밋되면 그 결과는 영구적으로 반영되어야 합니다.

#### 3.1.3 적용 방법

##### a) 비관적 락(Pessimistic Lock)

- **설명**: 데이터에 접근할 때 락을 걸어 다른 트랜잭션이 접근하지 못하도록 하는 방식입니다.
- **적용 방법**:
    - SQL의 `SELECT ... FOR UPDATE` 문을 사용합니다.
    - JPA에서는 `@Lock(LockModeType.PESSIMISTIC_WRITE)` 어노테이션을 사용합니다.
- **장점**:
    - 동시성 제어가 확실하여 데이터의 정합성을 보장합니다.
- **단점**:
    - 락으로 인한 대기 시간이 발생하여 성능이 저하될 수 있습니다.
    - 데드락의 위험이 있습니다.

##### b) 낙관적 락(Optimistic Lock)

- **설명**: 데이터 충돌이 드물다고 가정하고, 업데이트 시 충돌 여부를 확인하여 처리하는 방식입니다.
- **적용 방법**:
    - 엔티티에 `@Version` 어노테이션을 사용하여 버전 관리를 합니다.
- **장점**:
    - 락을 사용하지 않아 성능이 우수합니다.
    - 데이터 읽기 작업에 대한 병행성이 높습니다.
- **단점**:
    - 충돌 발생 시 예외가 발생하며, 재시도 로직이 필요합니다.
    - 충돌 빈도가 높을 경우 오히려 성능이 저하될 수 있습니다.

### 3.2 분산 락

#### 3.2.1 분산 락의 원리

- **설명**: 분산 시스템 환경에서 여러 노드가 공유 자원에 동시에 접근하는 것을 제어하기 위한 락입니다.
- **적용 방법**:
    - Redis와 같은 외부 시스템을 이용하여 락을 관리합니다.
    - Redis의 `SETNX` 명령어나 Redisson 라이브러리를 사용합니다.
- **장점**:
    - 분산 환경에서 동시성 제어가 가능합니다.
    - 빠른 성능과 높은 처리량을 제공합니다.
- **단점**:
    - 추가적인 인프라가 필요하며, 구현 복잡도가 높습니다.
    - 네트워크 지연이나 Redis 장애 시 문제가 발생할 수 있습니다.

#### 3.2.2 Redis를 활용한 분산 락 구현

- **Redis SETNX 명령어**:
    - `SETNX`(Set if Not Exists)는 키가 존재하지 않을 때만 값을 설정합니다.
    - 이를 이용하여 락을 획득하고, `EXPIRE` 명령어로 락의 유효 기간을 설정합니다.
- **락 획득 및 해제 절차**:
    1. **락 획득**: `SETNX` 명령어로 락 키를 설정합니다.
    2. **락 유지**: 작업을 수행합니다.
    3. **락 해제**: 작업 완료 후 `DEL` 명령어로 락 키를 삭제합니다.
- **주의 사항**:
    - 락의 유효 기간 설정으로 데드락을 방지해야 합니다.
    - 원자성을 보장하기 위해 Lua 스크립트나 Redisson 등의 라이브러리를 사용할 수 있습니다.

#### 3.2.3 제한 사항

- **구현 복잡도**:
    - 분산 락은 구현이 복잡하며, 잘못 구현하면 데이터 정합성이 깨질 수 있습니다.
- **추가 인프라 필요성**:
    - Redis 등의 외부 시스템을 구축하고 운영해야 합니다.
- **성능 영향**:
    - 네트워크 통신으로 인한 지연이 발생할 수 있습니다.

```markdown
